import {
  loadSetups
} from "./chunk-CYLMMBRG.mjs";
import {
  generateGoogleFontsUrl,
  resolveGlobalImportPath,
  resolveImportPath,
  stringifyMarkdownTokens,
  toAtFS
} from "./chunk-5L3XKTHL.mjs";
import {
  __commonJS,
  __toESM
} from "./chunk-65ITIFTL.mjs";

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal2(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node/common.ts
import { existsSync, promises as fs } from "node:fs";
import { join } from "node:path";
import { uniq } from "@antfu/utils";
import { loadConfigFromFile, mergeConfig } from "vite";
async function getIndexHtml({ clientRoot, themeRoots, addonRoots, data, userRoot }) {
  let main = await fs.readFile(join(clientRoot, "index.html"), "utf-8");
  let head = "";
  let body = "";
  head += `<link rel="icon" href="${data.config.favicon}">`;
  const roots = uniq([
    ...themeRoots,
    ...addonRoots,
    userRoot
  ]);
  for (const root of roots) {
    const path = join(root, "index.html");
    if (!existsSync(path))
      continue;
    const index = await fs.readFile(path, "utf-8");
    head += `
${(index.match(/<head>([\s\S]*?)<\/head>/im)?.[1] || "").trim()}`;
    body += `
${(index.match(/<body>([\s\S]*?)<\/body>/im)?.[1] || "").trim()}`;
  }
  if (data.features.tweet)
    body += '\n<script async src="https://platform.twitter.com/widgets.js"></script>';
  if (data.config.fonts.webfonts.length && data.config.fonts.provider !== "none")
    head += `
<link rel="stylesheet" href="${generateGoogleFontsUrl(data.config.fonts)}" type="text/css">`;
  main = main.replace("__ENTRY__", toAtFS(join(clientRoot, "main.ts"))).replace("<!-- head -->", head).replace("<!-- body -->", body);
  return main;
}
async function mergeViteConfigs({ addonRoots, themeRoots }, viteConfig, config, command) {
  const configEnv = {
    mode: "development",
    command
  };
  const files = uniq([
    ...themeRoots,
    ...addonRoots
  ]).map((i) => join(i, "vite.config.ts"));
  for await (const file of files) {
    if (!existsSync(file))
      continue;
    const viteConfig2 = await loadConfigFromFile(configEnv, file);
    if (!viteConfig2?.config)
      continue;
    config = mergeConfig(config, viteConfig2.config);
  }
  return mergeConfig(viteConfig, config);
}

// node/plugins/preset.ts
import { join as join8 } from "node:path";
import { existsSync as existsSync3 } from "node:fs";
import process3 from "node:process";
import Vue from "@vitejs/plugin-vue";
import VueJsx from "@vitejs/plugin-vue-jsx";
import Icons from "unplugin-icons/vite";
import IconsResolver from "unplugin-icons/resolver";
import Components from "unplugin-vue-components/vite";
import ServerRef from "vite-plugin-vue-server-ref";
import { notNullish as notNullish2 } from "@antfu/utils";

// node/drawings.ts
import { basename, dirname, join as join2, resolve } from "node:path";
import fs2 from "fs-extra";
import fg from "fast-glob";
function resolveDrawingsDir(options) {
  return options.data.config.drawings.persist ? resolve(
    dirname(options.entry),
    options.data.config.drawings.persist
  ) : void 0;
}
async function loadDrawings(options) {
  const dir = resolveDrawingsDir(options);
  if (!dir || !fs2.existsSync(dir))
    return {};
  const files = await fg("*.svg", {
    onlyFiles: true,
    cwd: dir,
    absolute: true,
    suppressErrors: true
  });
  const obj = {};
  await Promise.all(files.map(async (path) => {
    const num = +basename(path, ".svg");
    if (Number.isNaN(num))
      return;
    const content = await fs2.readFile(path, "utf8");
    const lines = content.split(/\n/g);
    obj[num.toString()] = lines.slice(1, -1).join("\n");
  }));
  return obj;
}
async function writeDrawings(options, drawing) {
  const dir = resolveDrawingsDir(options);
  if (!dir)
    return;
  const width = options.data.config.canvasWidth;
  const height = Math.round(width / options.data.config.aspectRatio);
  const SVG_HEAD = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">`;
  await fs2.ensureDir(dir);
  return Promise.all(
    Object.entries(drawing).map(async ([key, value]) => {
      if (!value)
        return;
      const svg = `${SVG_HEAD}
${value}
</svg>`;
      await fs2.writeFile(join2(dir, `${key}.svg`), svg, "utf-8");
    })
  );
}

// node/plugins/extendConfig.ts
import { dirname as dirname3, join as join4 } from "node:path";
import { mergeConfig as mergeConfig2 } from "vite";
import isInstalledGlobally from "is-installed-globally";
import { uniq as uniq2 } from "@antfu/utils";

// ../client/package.json
var dependencies = {
  "@antfu/utils": "^0.7.6",
  "@slidev/parser": "workspace:*",
  "@slidev/types": "workspace:*",
  "@unhead/vue": "^1.8.3",
  "@unocss/reset": "^0.57.3",
  "@vueuse/core": "^10.5.0",
  "@vueuse/math": "^10.5.0",
  "@vueuse/motion": "^2.0.0",
  codemirror: "^5.65.5",
  defu: "^6.1.3",
  drauu: "^0.3.7",
  "file-saver": "^2.0.5",
  "fuse.js": "^7.0.0",
  "js-base64": "^3.7.5",
  "js-yaml": "^4.1.0",
  katex: "^0.16.9",
  mermaid: "^10.6.1",
  "monaco-editor": "^0.37.1",
  nanoid: "^5.0.3",
  prettier: "^3.0.3",
  recordrtc: "^5.6.2",
  resolve: "^1.22.8",
  unocss: "^0.57.3",
  "vite-plugin-windicss": "^1.9.1",
  vue: "^3.3.8",
  "vue-router": "^4.2.5",
  "vue-starport": "^0.4.0",
  windicss: "^3.5.6"
};

// node/vite/searchRoot.ts
import fs3 from "node:fs";
import { dirname as dirname2, join as join3 } from "node:path";
var ROOT_FILES = [
  // '.git',
  // https://pnpm.js.org/workspaces/
  "pnpm-workspace.yaml"
  // https://rushjs.io/pages/advanced/config_files/
  // 'rush.json',
  // https://nx.dev/latest/react/getting-started/nx-setup
  // 'workspace.json',
  // 'nx.json'
];
function hasWorkspacePackageJSON(root) {
  const path = join3(root, "package.json");
  try {
    fs3.accessSync(path, fs3.constants.R_OK);
  } catch {
    return false;
  }
  const content = JSON.parse(fs3.readFileSync(path, "utf-8")) || {};
  return !!content.workspaces;
}
function hasRootFile(root) {
  return ROOT_FILES.some((file) => fs3.existsSync(join3(root, file)));
}
function hasPackageJSON(root) {
  const path = join3(root, "package.json");
  return fs3.existsSync(path);
}
function searchForPackageRoot(current, root = current) {
  if (hasPackageJSON(current))
    return current;
  const dir = dirname2(current);
  if (!dir || dir === current)
    return root;
  return searchForPackageRoot(dir, root);
}
function searchForWorkspaceRoot(current, root = searchForPackageRoot(current)) {
  if (hasRootFile(current))
    return current;
  if (hasWorkspacePackageJSON(current))
    return current;
  const dir = dirname2(current);
  if (!dir || dir === current)
    return root;
  return searchForWorkspaceRoot(dir, root);
}

// node/plugins/extendConfig.ts
var EXCLUDE = [
  "@slidev/shared",
  "@slidev/types",
  "@slidev/client",
  "@slidev/client/constants",
  "@slidev/client/logic/dark",
  "@vueuse/core",
  "@vueuse/shared",
  "@unocss/reset",
  "unocss",
  "mermaid",
  "vite-plugin-windicss",
  "vue-demi",
  "vue"
];
function createConfigPlugin(options) {
  return {
    name: "slidev:config",
    async config(config) {
      const injection = {
        define: getDefine(options),
        resolve: {
          alias: {
            "@slidev/client/": `${toAtFS(options.clientRoot)}/`
          },
          dedupe: ["vue"]
        },
        optimizeDeps: {
          include: [
            ...Object.keys(dependencies).filter((i) => !EXCLUDE.includes(i)),
            "codemirror/mode/javascript/javascript",
            "codemirror/mode/css/css",
            "codemirror/mode/markdown/markdown",
            "codemirror/mode/xml/xml",
            "codemirror/mode/htmlmixed/htmlmixed",
            "codemirror/addon/display/placeholder",
            "prettier/plugins/babel",
            "prettier/plugins/html",
            "prettier/plugins/typescript",
            "mermaid/dist/mermaid.esm.min.mjs",
            "mermaid/dist/mermaid.esm.mjs",
            "vite-plugin-vue-server-ref/client"
          ],
          exclude: EXCLUDE
        },
        css: options.data.config.css === "unocss" ? {
          postcss: {
            plugins: [
              await import("postcss-nested").then((r) => (r.default || r)())
            ]
          }
        } : {},
        server: {
          fs: {
            strict: true,
            allow: uniq2([
              searchForWorkspaceRoot(options.userRoot),
              searchForWorkspaceRoot(options.cliRoot),
              ...isInstalledGlobally ? [dirname3(resolveGlobalImportPath("@slidev/client/package.json")), dirname3(resolveGlobalImportPath("katex/package.json"))] : []
            ])
          }
        },
        publicDir: join4(options.userRoot, "public")
      };
      if (isInstalledGlobally) {
        injection.cacheDir = join4(options.cliRoot, "node_modules/.vite");
        injection.root = options.cliRoot;
        injection.resolve.alias.vue = `${resolveImportPath("vue/dist/vue.esm-browser.js", true)}`;
      }
      return mergeConfig2(injection, config);
    },
    configureServer(server) {
      return () => {
        server.middlewares.use(async (req, res, next) => {
          if (req.url.endsWith(".html")) {
            res.setHeader("Content-Type", "text/html");
            res.statusCode = 200;
            res.end(await getIndexHtml(options));
            return;
          }
          next();
        });
      };
    }
  };
}
function getDefine(options) {
  return {
    __DEV__: options.mode === "dev" ? "true" : "false",
    __SLIDEV_CLIENT_ROOT__: JSON.stringify(toAtFS(options.clientRoot)),
    __SLIDEV_HASH_ROUTE__: JSON.stringify(options.data.config.routerMode === "hash"),
    __SLIDEV_FEATURE_DRAWINGS__: JSON.stringify(options.data.config.drawings.enabled === true || options.data.config.drawings.enabled === options.mode),
    __SLIDEV_FEATURE_EDITOR__: JSON.stringify(options.mode === "dev" && options.data.config.editor !== false),
    __SLIDEV_FEATURE_DRAWINGS_PERSIST__: JSON.stringify(!!options.data.config.drawings.persist === true),
    __SLIDEV_FEATURE_RECORD__: JSON.stringify(options.data.config.record === true || options.data.config.record === options.mode),
    __SLIDEV_FEATURE_PRESENTER__: JSON.stringify(options.data.config.presenter === true || options.data.config.presenter === options.mode),
    __SLIDEV_HAS_SERVER__: options.mode !== "build" ? "true" : "false"
  };
}

// node/plugins/loaders.ts
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
import { basename as basename2, join as join5 } from "node:path";
import process from "node:process";
import { isString, notNullish, objectMap, range, slash, uniq as uniq3 } from "@antfu/utils";
import fg2 from "fast-glob";
import fs4 from "fs-extra";
import Markdown from "markdown-it";
import { bold, gray, red, yellow } from "kolorist";
import mila from "markdown-it-link-attributes";
import * as parser from "@slidev/parser/fs";
var regexId = /^\/\@slidev\/slide\/(\d+)\.(md|json)(?:\?import)?$/;
var regexIdQuery = /(\d+?)\.(md|json|frontmatter)$/;
var vueContextImports = [
  'import { inject as _vueInject, provide as _vueProvide, toRef as _vueToRef } from "vue"',
  `import {
    injectionSlidevContext as _injectionSlidevContext, 
    injectionClicks as _injectionClicks,
    injectionCurrentPage as _injectionCurrentPage,
    injectionRenderContext as _injectionRenderContext,
    injectionFrontmatter as _injectionFrontmatter,
  } from "@slidev/client/constants.ts"`.replace(/\n\s+/g, "\n"),
  "const $slidev = _vueInject(_injectionSlidevContext)",
  'const $nav = _vueToRef($slidev, "nav")',
  "const $clicks = _vueInject(_injectionClicks)",
  "const $page = _vueInject(_injectionCurrentPage)",
  "const $renderContext = _vueInject(_injectionRenderContext)"
];
function getBodyJson(req) {
  return new Promise((resolve3, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve3(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}
var md = Markdown({ html: true });
md.use(mila, {
  attrs: {
    target: "_blank",
    rel: "noopener"
  }
});
function prepareSlideInfo(data) {
  return {
    ...data,
    noteHTML: md.render(data?.note || "")
  };
}
function createSlidesLoader({ data, entry, clientRoot, themeRoots, addonRoots, userRoot, roots, remote, mode }, pluginOptions, serverOptions) {
  const slidePrefix = "/@slidev/slides/";
  const hmrPages = /* @__PURE__ */ new Set();
  let server;
  let _layouts_cache_time = 0;
  let _layouts_cache = {};
  return [
    {
      name: "slidev:loader",
      configureServer(_server) {
        server = _server;
        updateServerWatcher();
        server.middlewares.use(async (req, res, next) => {
          const match = req.url?.match(regexId);
          if (!match)
            return next();
          const [, no, type] = match;
          const idx = Number.parseInt(no);
          if (type === "json" && req.method === "GET") {
            res.write(JSON.stringify(prepareSlideInfo(data.slides[idx])));
            return res.end();
          }
          if (type === "json" && req.method === "POST") {
            const body = await getBodyJson(req);
            const slide = data.slides[idx];
            hmrPages.add(idx);
            if (slide.source) {
              Object.assign(slide.source, body);
              await parser.saveExternalSlide(slide.source);
            } else {
              Object.assign(slide, body);
              await parser.save(data, entry);
            }
            res.statusCode = 200;
            res.write(JSON.stringify(prepareSlideInfo(slide)));
            return res.end();
          }
          next();
        });
      },
      async handleHotUpdate(ctx) {
        if (!data.entries.some((i) => slash(i) === ctx.file))
          return;
        await ctx.read();
        const newData = await parser.load(entry, data.themeMeta);
        const moduleIds = /* @__PURE__ */ new Set();
        if (data.slides.length !== newData.slides.length) {
          moduleIds.add("/@slidev/routes");
          range(newData.slides.length).map((i) => hmrPages.add(i));
        }
        if (!(0, import_fast_deep_equal.default)(data.headmatter.defaults, newData.headmatter.defaults)) {
          moduleIds.add("/@slidev/routes");
          range(data.slides.length).map((i) => hmrPages.add(i));
        }
        if (!(0, import_fast_deep_equal.default)(data.config, newData.config))
          moduleIds.add("/@slidev/configs");
        if (!(0, import_fast_deep_equal.default)(data.features, newData.features)) {
          setTimeout(() => {
            ctx.server.ws.send({ type: "full-reload" });
          }, 1);
        }
        const length = Math.max(data.slides.length, newData.slides.length);
        for (let i = 0; i < length; i++) {
          const a = data.slides[i];
          const b = newData.slides[i];
          if (a?.content.trim() === b?.content.trim() && a?.title?.trim() === b?.title?.trim() && a?.note === b?.note && (0, import_fast_deep_equal.default)(a.frontmatter, b.frontmatter))
            continue;
          ctx.server.ws.send({
            type: "custom",
            event: "slidev-update",
            data: {
              id: i,
              data: prepareSlideInfo(newData.slides[i])
            }
          });
          hmrPages.add(i);
        }
        serverOptions.onDataReload?.(newData, data);
        Object.assign(data, newData);
        if (hmrPages.size > 0)
          moduleIds.add("/@slidev/titles.md");
        const vueModules = Array.from(hmrPages).flatMap((i) => [
          ctx.server.moduleGraph.getModuleById(`${slidePrefix}${i + 1}.frontmatter`),
          ctx.server.moduleGraph.getModuleById(`${slidePrefix}${i + 1}.md`)
        ]);
        hmrPages.clear();
        const moduleEntries = [
          ...vueModules,
          ...Array.from(moduleIds).map((id) => ctx.server.moduleGraph.getModuleById(id))
        ].filter(notNullish).filter((i) => !i.id?.startsWith("/@id/@vite-icons"));
        updateServerWatcher();
        return moduleEntries;
      },
      resolveId(id) {
        if (id.startsWith(slidePrefix) || id.startsWith("/@slidev/"))
          return id;
        return null;
      },
      load(id) {
        if (id === "/@slidev/routes")
          return generateRoutes();
        if (id === "/@slidev/layouts")
          return generateLayouts();
        if (id === "/@slidev/styles")
          return generateUserStyles();
        if (id === "/@slidev/monaco-types")
          return generateMonacoTypes();
        if (id === "/@slidev/configs")
          return generateConfigs();
        if (id === "/@slidev/global-components/top")
          return generateGlobalComponents("top");
        if (id === "/@slidev/global-components/bottom")
          return generateGlobalComponents("bottom");
        if (id === "/@slidev/custom-nav-controls")
          return generateCustomNavControls();
        if (id === "/@slidev/titles.md") {
          return {
            code: data.slides.filter(({ frontmatter }) => !frontmatter?.disabled).map(({ title }, i) => `<template ${i === 0 ? "v-if" : "v-else-if"}="+no === ${i + 1}">

${title}

</template>`).join(""),
            map: { mappings: "" }
          };
        }
        if (id.startsWith(slidePrefix)) {
          const remaning = id.slice(slidePrefix.length);
          const match = remaning.match(regexIdQuery);
          if (match) {
            const [, no, type] = match;
            const pageNo = Number.parseInt(no) - 1;
            const slide = data.slides[pageNo];
            if (!slide)
              return;
            if (type === "md") {
              return {
                code: slide?.content,
                map: { mappings: "" }
              };
            } else if (type === "frontmatter") {
              return {
                code: [
                  "// @unocss-include",
                  'import { reactive, computed } from "vue"',
                  `export const frontmatter = reactive(${JSON.stringify(slide.frontmatter)})`,
                  `export const meta = reactive({
                    layout: computed(() => frontmatter.layout),
                    transition: computed(() => frontmatter.transition),
                    class: computed(() => frontmatter.class),
                    clicks: computed(() => frontmatter.clicks),
                    name: computed(() => frontmatter.name),
                    preload: computed(() => frontmatter.preload),
                    slide: {
                      ...(${JSON.stringify({
                    ...prepareSlideInfo(slide),
                    frontmatter: void 0,
                    // remove raw content in build, optimize the bundle size
                    ...mode === "build" ? { raw: "", content: "", note: "" } : {}
                  })}),
                      frontmatter,
                      filepath: ${JSON.stringify(slide.source?.filepath || entry)},
                      id: ${pageNo},
                      no: ${no},
                    },
                    __clicksElements: [],
                    __preloaded: false,
                  })`,
                  "export default frontmatter",
                  // handle HMR, update frontmatter with update
                  "if (import.meta.hot) {",
                  "  import.meta.hot.accept(({ frontmatter: update }) => {",
                  "    if(!update) return",
                  "    Object.keys(frontmatter).forEach(key => {",
                  "      if (!(key in update)) delete frontmatter[key]",
                  "    })",
                  "    Object.assign(frontmatter, update)",
                  "  })",
                  "}"
                ].join("\n"),
                map: { mappings: "" }
              };
            }
          }
          return {
            code: "",
            map: { mappings: "" }
          };
        }
      }
    },
    {
      name: "slidev:layout-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.startsWith(slidePrefix))
          return;
        const remaning = id.slice(slidePrefix.length);
        const match = remaning.match(regexIdQuery);
        if (!match)
          return;
        const [, no, type] = match;
        if (type !== "md")
          return;
        const pageNo = Number.parseInt(no) - 1;
        return transformMarkdown(code, pageNo, data);
      }
    },
    {
      name: "slidev:context-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.endsWith(".vue") || id.includes("/@slidev/client/") || id.includes("/packages/client/"))
          return;
        return transformVue(code);
      }
    },
    {
      name: "slidev:title-transform:pre",
      enforce: "pre",
      transform(code, id) {
        if (id !== "/@slidev/titles.md")
          return;
        return transformTitles(code);
      }
    },
    {
      name: "slidev:slide-transform:post",
      enforce: "post",
      transform(code, id) {
        if (!id.match(/\/@slidev\/slides\/\d+\.md($|\?)/))
          return;
        const replaced = code.replace("if (_rerender_only)", "if (false)");
        if (replaced !== code)
          return replaced;
      }
    }
  ];
  function updateServerWatcher() {
    if (!server)
      return;
    server.watcher.add(data.entries?.map(slash) || []);
  }
  async function transformMarkdown(code, pageNo, data2) {
    const layouts = await getLayouts();
    const frontmatter = {
      ...data2.headmatter?.defaults || {},
      ...data2.slides[pageNo]?.frontmatter || {}
    };
    let layoutName = frontmatter?.layout || (pageNo === 0 ? "cover" : "default");
    if (!layouts[layoutName]) {
      console.error(red(`
Unknown layout "${bold(layoutName)}".${yellow(" Available layouts are:")}`) + Object.keys(layouts).map((i, idx) => (idx % 3 === 0 ? "\n    " : "") + gray(i.padEnd(15, " "))).join("  "));
      console.error();
      layoutName = "default";
    }
    delete frontmatter.title;
    const imports = [
      ...vueContextImports,
      `import InjectedLayout from "${toAtFS(layouts[layoutName])}"`,
      `import frontmatter from "${toAtFS(`${slidePrefix + (pageNo + 1)}.frontmatter`)}"`,
      "const $frontmatter = frontmatter",
      "_vueProvide(_injectionFrontmatter, frontmatter)",
      // update frontmatter in router
      ";(() => {",
      "  const route = $slidev.nav.rawRoutes.find(i => i.path === String($page.value))",
      "  if (route?.meta?.slide?.frontmatter) {",
      "    Object.keys(route.meta.slide.frontmatter).forEach(key => {",
      "      if (!(key in $frontmatter)) delete route.meta.slide.frontmatter[key]",
      "    })",
      "    Object.assign(route.meta.slide.frontmatter, frontmatter)",
      "  }",
      "})();"
    ];
    code = code.replace(/(<script setup.*>)/g, `$1
${imports.join("\n")}
`);
    const injectA = code.indexOf("<template>") + "<template>".length;
    const injectB = code.lastIndexOf("</template>");
    let body = code.slice(injectA, injectB).trim();
    if (body.startsWith("<div>") && body.endsWith("</div>"))
      body = body.slice(5, -6);
    code = `${code.slice(0, injectA)}
<InjectedLayout v-bind="frontmatter">
${body}
</InjectedLayout>
${code.slice(injectB)}`;
    return code;
  }
  function transformVue(code) {
    if (code.includes("injectionSlidevContext") || code.includes("injectionClicks") || code.includes("const $slidev"))
      return code;
    const imports = [
      ...vueContextImports,
      "const $frontmatter = _vueInject(_injectionFrontmatter)"
    ];
    const matchScript = code.match(/<script((?!setup).)*(setup)?.*>/);
    if (matchScript && matchScript[2]) {
      return code.replace(/(<script.*>)/g, `$1
${imports.join("\n")}
`);
    } else if (matchScript && !matchScript[2]) {
      const matchExport = code.match(/export\s+default\s+{/);
      if (matchExport) {
        const exportIndex = (matchExport.index || 0) + matchExport[0].length;
        let component = code.slice(exportIndex);
        component = component.slice(0, component.indexOf("</script>"));
        const scriptIndex = (matchScript.index || 0) + matchScript[0].length;
        const provideImport = '\nimport { injectionSlidevContext } from "@slidev/client/constants.ts"\n';
        code = `${code.slice(0, scriptIndex)}${provideImport}${code.slice(scriptIndex)}`;
        let injectIndex = exportIndex + provideImport.length;
        let injectObject = "$slidev: { from: injectionSlidevContext },";
        const matchInject = component.match(/.*inject\s*:\s*([\[{])/);
        if (matchInject) {
          injectIndex += (matchInject.index || 0) + matchInject[0].length;
          if (matchInject[1] === "[") {
            let injects = component.slice((matchInject.index || 0) + matchInject[0].length);
            const injectEndIndex = injects.indexOf("]");
            injects = injects.slice(0, injectEndIndex);
            injectObject += injects.split(",").map((inject) => `${inject}: {from: ${inject}}`).join(",");
            return `${code.slice(0, injectIndex - 1)}{
${injectObject}
}${code.slice(injectIndex + injectEndIndex + 1)}`;
          } else {
            return `${code.slice(0, injectIndex)}
${injectObject}
${code.slice(injectIndex)}`;
          }
        }
        return `${code.slice(0, injectIndex)}
inject: { ${injectObject} },
${code.slice(injectIndex)}`;
      }
    }
    return `<script setup>
${imports.join("\n")}
</script>
${code}`;
  }
  function transformTitles(code) {
    return code.replace(/<template>\s*<div>\s*<p>/, "<template>").replace(/<\/p>\s*<\/div>\s*<\/template>/, "</template>").replace(/<script\ssetup>/, `<script setup lang="ts">
defineProps<{ no: number | string }>()`);
  }
  async function getLayouts() {
    const now = Date.now();
    if (now - _layouts_cache_time < 2e3)
      return _layouts_cache;
    const layouts = {};
    const roots2 = uniq3([
      userRoot,
      ...themeRoots,
      ...addonRoots,
      clientRoot
    ]);
    for (const root of roots2) {
      const layoutPaths = await fg2("layouts/**/*.{vue,ts}", {
        cwd: root,
        absolute: true,
        suppressErrors: true
      });
      for (const layoutPath of layoutPaths) {
        const layout = basename2(layoutPath).replace(/\.\w+$/, "");
        if (layouts[layout])
          continue;
        layouts[layout] = layoutPath;
      }
    }
    _layouts_cache_time = now;
    _layouts_cache = layouts;
    return layouts;
  }
  async function generateUserStyles() {
    const imports = [
      `import "${toAtFS(join5(clientRoot, "styles/vars.css"))}"`,
      `import "${toAtFS(join5(clientRoot, "styles/index.css"))}"`,
      `import "${toAtFS(join5(clientRoot, "styles/code.css"))}"`,
      `import "${toAtFS(join5(clientRoot, "styles/katex.css"))}"`,
      `import "${toAtFS(join5(clientRoot, "styles/transitions.css"))}"`
    ];
    const roots2 = uniq3([
      ...themeRoots,
      ...addonRoots,
      userRoot
    ]);
    for (const root of roots2) {
      const styles = [
        join5(root, "styles", "index.ts"),
        join5(root, "styles", "index.js"),
        join5(root, "styles", "index.css"),
        join5(root, "styles.css"),
        join5(root, "style.css")
      ];
      for (const style of styles) {
        if (fs4.existsSync(style)) {
          imports.push(`import "${toAtFS(style)}"`);
          continue;
        }
      }
    }
    if (data.features.katex)
      imports.push(`import "${toAtFS(resolveImportPath("katex/dist/katex.min.css", true))}"`);
    if (data.config.css === "unocss") {
      imports.unshift(
        'import "@unocss/reset/tailwind.css"',
        'import "uno:preflights.css"',
        'import "uno:typography.css"',
        'import "uno:shortcuts.css"'
      );
      imports.push('import "uno.css"');
    } else {
      imports.unshift(
        'import "virtual:windi-components.css"',
        'import "virtual:windi-base.css"'
      );
      imports.push('import "virtual:windi-utilities.css"');
      if (process.env.NODE_ENV !== "production")
        imports.push('import "virtual:windi-devtools"');
    }
    return imports.join("\n");
  }
  async function generateMonacoTypes() {
    return `void 0; ${parser.scanMonacoModules(data.raw).map((i) => `import('/@slidev-monaco-types/${i}')`).join("\n")}`;
  }
  async function generateLayouts() {
    const imports = [];
    const layouts = objectMap(
      await getLayouts(),
      (k, v) => {
        imports.push(`import __layout_${k} from "${toAtFS(v)}"`);
        return [k, `__layout_${k}`];
      }
    );
    return [
      imports.join("\n"),
      `export default {
${Object.entries(layouts).map(([k, v]) => `"${k}": ${v}`).join(",\n")}
}`
    ].join("\n\n");
  }
  async function generateRoutes() {
    const imports = [];
    const redirects = [];
    const layouts = await getLayouts();
    imports.push(`import __layout__end from '${layouts.end}'`);
    let no = 1;
    const routes = data.slides.filter(({ frontmatter }) => !frontmatter?.disabled).map((i, idx) => {
      imports.push(`import n${no} from '${slidePrefix}${idx + 1}.md'`);
      imports.push(`import { meta as f${no} } from '${slidePrefix}${idx + 1}.frontmatter'`);
      const route = `{ path: '${no}', name: 'page-${no}', component: n${no}, meta: f${no} }`;
      if (i.frontmatter?.routeAlias)
        redirects.push(`{ path: '${i.frontmatter?.routeAlias}', redirect: { path: '${no}' } }`);
      no += 1;
      return route;
    });
    const routesStr = `export default [
${routes.join(",\n")}
]`;
    const redirectsStr = `export const redirects = [
${redirects.join(",\n")}
]`;
    return [...imports, routesStr, redirectsStr].join("\n");
  }
  function generateConfigs() {
    const config = { ...data.config, remote };
    if (isString(config.title)) {
      const tokens = md.parseInline(config.title, {});
      config.title = stringifyMarkdownTokens(tokens);
    }
    if (isString(config.info))
      config.info = md.render(config.info);
    return `export default ${JSON.stringify(config)}`;
  }
  async function generateGlobalComponents(layer) {
    const components = roots.flatMap((root) => {
      if (layer === "top") {
        return [
          join5(root, "global.vue"),
          join5(root, "global-top.vue"),
          join5(root, "GlobalTop.vue")
        ];
      } else {
        return [
          join5(root, "global-bottom.vue"),
          join5(root, "GlobalBottom.vue")
        ];
      }
    }).filter((i) => fs4.existsSync(i));
    const imports = components.map((i, idx) => `import __n${idx} from '${toAtFS(i)}'`).join("\n");
    const render = components.map((i, idx) => `h(__n${idx})`).join(",");
    return `
${imports}
import { h } from 'vue'
export default {
  render() {
    return [${render}]
  }
}
`;
  }
  async function generateCustomNavControls() {
    const components = roots.flatMap((root) => {
      return [
        join5(root, "custom-nav-controls.vue"),
        join5(root, "CustomNavControls.vue")
      ];
    }).filter((i) => fs4.existsSync(i));
    const imports = components.map((i, idx) => `import __n${idx} from '${toAtFS(i)}'`).join("\n");
    const render = components.map((i, idx) => `h(__n${idx})`).join(",");
    return `
${imports}
import { h } from 'vue'
export default {
  render() {
    return [${render}]
  }
}
`;
  }
}

// node/plugins/monacoTransform.ts
import { dirname as dirname4, join as join6 } from "node:path";
import fs5 from "node:fs/promises";
import process2 from "node:process";
import { slash as slash2 } from "@antfu/utils";
import { findDepPkgJsonPath } from "vitefu";
async function getPackageData(pkg) {
  const pkgJsonPath = await findDepPkgJsonPath(pkg, process2.cwd());
  if (!pkgJsonPath)
    return;
  const pkgJson = JSON.parse(await fs5.readFile(pkgJsonPath, "utf-8"));
  const typePath = pkgJson.types || pkgJson.typings;
  if (!typePath)
    return;
  return [dirname4(pkgJsonPath), pkgJson, typePath];
}
function createMonacoTypesLoader() {
  return {
    name: "slidev:monaco-types-loader",
    resolveId(id) {
      if (id.startsWith("/@slidev-monaco-types/"))
        return id;
      return null;
    },
    async load(id) {
      const match = id.match(/^\/\@slidev-monaco-types\/(.*)$/);
      if (match) {
        const pkg = match[1];
        const packageData = await getPackageData(pkg) || await getPackageData(`@types/${pkg}`);
        if (!packageData)
          return;
        const [pkgDir, pkgJson, typePath] = packageData;
        return [
          "import * as monaco from 'monaco-editor'",
          `import Type from "${slash2(join6(pkgDir, typePath))}?raw"`,
          ...Object.keys(pkgJson.dependencies || {}).map((i) => `import "/@slidev-monaco-types/${i}"`),
          `monaco.languages.typescript.typescriptDefaults.addExtraLib(\`declare module "${pkg}" { \${Type} }\`)`
        ].join("\n");
      }
    }
  };
}

// node/plugins/setupClient.ts
import { existsSync as existsSync2 } from "node:fs";
import { join as join7, resolve as resolve2 } from "node:path";
import { slash as slash3, uniq as uniq4 } from "@antfu/utils";
function createClientSetupPlugin({ clientRoot, themeRoots, addonRoots, userRoot }) {
  const setupEntry = slash3(resolve2(clientRoot, "setup"));
  return {
    name: "slidev:setup",
    enforce: "pre",
    async transform(code, id) {
      if (id.startsWith(setupEntry)) {
        let getInjections2 = function(isAwait = false, isChained = false) {
          return injections.join("\n").replace(/:AWAIT:/g, isAwait ? "await " : "").replace(/(,\s*)?:LAST:/g, isChained ? "$1injection_return" : "");
        };
        var getInjections = getInjections2;
        const name = id.slice(setupEntry.length + 1).replace(/\?.*$/, "");
        const imports = [];
        const injections = [];
        const setups = uniq4([
          ...themeRoots,
          ...addonRoots,
          userRoot
        ]).map((i) => join7(i, "setup", name));
        setups.forEach((path, idx) => {
          if (!existsSync2(path))
            return;
          imports.push(`import __n${idx} from '${toAtFS(path)}'`);
          let fn = `:AWAIT:__n${idx}`;
          if (/\binjection_return\b/g.test(code))
            fn = `injection_return = ${fn}`;
          if (/\binjection_arg\b/g.test(code)) {
            fn += "(";
            const matches = Array.from(code.matchAll(/\binjection_arg(_\d+)?\b/g));
            const dedupedMatches = Array.from(new Set(matches.map((m) => m[0])));
            fn += dedupedMatches.join(", ");
            fn += ", :LAST:)";
          } else {
            fn += "(:LAST:)";
          }
          injections.push(
            `// ${path}`,
            fn
          );
        });
        code = code.replace("/* __imports__ */", imports.join("\n"));
        code = code.replace("/* __injections__ */", getInjections2());
        code = code.replace("/* __async_injections__ */", getInjections2(true));
        code = code.replace("/* __chained_injections__ */", getInjections2(false, true));
        code = code.replace("/* __chained_async_injections__ */", getInjections2(true, true));
        return code;
      }
      return null;
    }
  };
}

// node/plugins/markdown.ts
import Markdown2 from "unplugin-vue-markdown/vite";
import * as base64 from "js-base64";
import { slash as slash4 } from "@antfu/utils";
import mila2 from "markdown-it-link-attributes";
import mif from "markdown-it-footnote";
import { taskLists } from "@hedgedoc/markdown-it-plugins";
import { encode as encode2 } from "plantuml-encoder";
import Mdc from "markdown-it-mdc";

// node/plugins/markdown-it-katex.ts
import katex from "katex";
function isValidDelim(state, pos) {
  const max = state.posMax;
  let can_open = true;
  let can_close = true;
  const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
  const nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
  if (prevChar === 32 || prevChar === 9 || /* \t */
  nextChar >= 48 && nextChar <= 57)
    can_close = false;
  if (nextChar === 32 || nextChar === 9)
    can_open = false;
  return {
    can_open,
    can_close
  };
}
function math_inline(state, silent) {
  let match, token, res, pos;
  if (state.src[state.pos] !== "$")
    return false;
  res = isValidDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent)
      state.pending += "$";
    state.pos += 1;
    return true;
  }
  const start = state.pos + 1;
  match = start;
  while ((match = state.src.indexOf("$", match)) !== -1) {
    pos = match - 1;
    while (state.src[pos] === "\\")
      pos -= 1;
    if ((match - pos) % 2 === 1)
      break;
    match += 1;
  }
  if (match === -1) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (match - start === 0) {
    if (!silent)
      state.pending += "$$";
    state.pos = start + 1;
    return true;
  }
  res = isValidDelim(state, match);
  if (!res.can_close) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (!silent) {
    token = state.push("math_inline", "math", 0);
    token.markup = "$";
    token.content = state.src.slice(start, match);
  }
  state.pos = match + 1;
  return true;
}
function math_block(state, start, end, silent) {
  let firstLine;
  let lastLine;
  let next;
  let lastPos;
  let found = false;
  let pos = state.bMarks[start] + state.tShift[start];
  let max = state.eMarks[start];
  if (pos + 2 > max)
    return false;
  if (state.src.slice(pos, pos + 2) !== "$$")
    return false;
  pos += 2;
  firstLine = state.src.slice(pos, max);
  if (silent)
    return true;
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next = start; !found; ) {
    next++;
    if (next >= end)
      break;
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next + 1;
  const token = state.push("math_block", "math", 0);
  token.block = true;
  token.content = (firstLine && firstLine.trim() ? `${firstLine}
` : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token.map = [start, state.line];
  token.markup = "$$";
  return true;
}
function math_plugin(md2, options) {
  options = options || {};
  const katexInline = function(latex) {
    options.displayMode = false;
    try {
      return katex.renderToString(latex, options);
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const inlineRenderer = function(tokens, idx) {
    return katexInline(tokens[idx].content);
  };
  const katexBlock = function(latex) {
    options.displayMode = true;
    try {
      return `<p>${katex.renderToString(latex, options)}</p>`;
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const blockRenderer = function(tokens, idx) {
    return `${katexBlock(tokens[idx].content)}
`;
  };
  md2.inline.ruler.after("escape", "math_inline", math_inline);
  md2.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md2.renderer.rules.math_inline = inlineRenderer;
  md2.renderer.rules.math_block = blockRenderer;
}

// node/plugins/markdown-it-prism.ts
import { createRequire } from "node:module";
import Prism from "prismjs";
import loadLanguages from "prismjs/components/index.js";
import * as htmlparser2 from "htmlparser2";
var require2 = createRequire(import.meta.url);
var Tag = class {
  tagname;
  attributes;
  constructor(tagname, attributes) {
    this.tagname = tagname;
    this.attributes = attributes;
  }
  asOpen() {
    return `<${this.tagname} ${Object.entries(this.attributes).map(([key, value]) => `${key}="${value}"`).join(" ")}>`;
  }
  asClosed() {
    return `</${this.tagname}>`;
  }
};
var DEFAULTS = {
  plugins: [],
  init: () => {
  },
  defaultLanguageForUnknown: void 0,
  defaultLanguageForUnspecified: void 0,
  defaultLanguage: void 0
};
function loadPrismLang(lang) {
  if (!lang)
    return void 0;
  let langObject = Prism.languages[lang];
  if (langObject === void 0) {
    loadLanguages([lang]);
    langObject = Prism.languages[lang];
  }
  return langObject;
}
function loadPrismPlugin(name) {
  try {
    require2(`prismjs/plugins/${name}/prism-${name}`);
  } catch (e) {
    throw new Error(`Cannot load Prism plugin "${name}". Please check the spelling.`);
  }
}
function selectLanguage(options, lang) {
  let langToUse = lang;
  if (langToUse === "" && options.defaultLanguageForUnspecified !== void 0)
    langToUse = options.defaultLanguageForUnspecified;
  let prismLang = loadPrismLang(langToUse);
  if (prismLang === void 0 && options.defaultLanguageForUnknown !== void 0) {
    langToUse = options.defaultLanguageForUnknown;
    prismLang = loadPrismLang(langToUse);
  }
  return [langToUse, prismLang];
}
function highlight(markdownit, options, text, lang) {
  const [langToUse, prismLang] = selectLanguage(options, lang);
  let code = text.trimEnd();
  code = prismLang ? highlightPrism(code, prismLang, langToUse) : markdownit.utils.escapeHtml(code);
  code = code.split(/\r?\n/g).map((line) => `<span class="line">${line}</span>`).join("\n");
  const classAttribute = langToUse ? ` class="slidev-code ${markdownit.options.langPrefix}${markdownit.utils.escapeHtml(langToUse)}"` : "";
  return escapeVueInCode(`<pre${classAttribute}><code>${code}</code></pre>`);
}
function highlightPrism(code, prismLang, langToUse) {
  const openTags = [];
  const parser2 = new htmlparser2.Parser({
    onopentag(tagname, attributes) {
      openTags.push(new Tag(tagname, attributes));
    },
    onclosetag() {
      openTags.pop();
    }
  });
  code = Prism.highlight(code, prismLang, langToUse);
  code = code.split(/\r?\n/g).map((line) => {
    const prefix = openTags.map((tag) => tag.asOpen()).join("");
    parser2.write(line);
    const postfix = openTags.reverse().map((tag) => tag.asClosed()).join("");
    return prefix + line + postfix;
  }).join("\n");
  parser2.end();
  return code;
}
function checkLanguageOption(options, optionName) {
  const language = options[optionName];
  if (language !== void 0 && loadPrismLang(language) === void 0)
    throw new Error(`Bad option ${optionName}: There is no Prism language '${language}'.`);
}
function markdownItPrism(markdownit, useroptions) {
  const options = Object.assign({}, DEFAULTS, useroptions);
  checkLanguageOption(options, "defaultLanguage");
  checkLanguageOption(options, "defaultLanguageForUnknown");
  checkLanguageOption(options, "defaultLanguageForUnspecified");
  options.defaultLanguageForUnknown = options.defaultLanguageForUnknown || options.defaultLanguage;
  options.defaultLanguageForUnspecified = options.defaultLanguageForUnspecified || options.defaultLanguage;
  options.plugins.forEach(loadPrismPlugin);
  options.init(Prism);
  markdownit.options.highlight = (text, lang) => highlight(markdownit, options, text, lang);
}

// node/plugins/markdown-it-shiki.ts
function getThemeName(theme) {
  if (typeof theme === "string")
    return theme;
  return theme.name;
}
function isShikiDarkModeThemes(theme) {
  return typeof theme === "object" && ("dark" in theme || "light" in theme);
}
function resolveShikiOptions(options) {
  const themes = [];
  let darkModeThemes;
  if (!options.theme) {
    themes.push("nord");
  } else if (typeof options.theme === "string") {
    themes.push(options.theme);
  } else {
    if (isShikiDarkModeThemes(options.theme)) {
      darkModeThemes = options.theme;
      themes.push(options.theme.dark);
      themes.push(options.theme.light);
    } else {
      themes.push(options.theme);
    }
  }
  return {
    ...options,
    themes,
    darkModeThemes: darkModeThemes ? {
      dark: getThemeName(darkModeThemes.dark),
      light: getThemeName(darkModeThemes.light)
    } : void 0
  };
}
function trimEndNewLine(code) {
  return code.replace(/\n$/, "");
}
var MarkdownItShiki = (markdownit, options = {}) => {
  const _highlighter = options.highlighter;
  const { darkModeThemes } = resolveShikiOptions(options);
  markdownit.options.highlight = (code, lang) => {
    if (darkModeThemes) {
      const trimmed = trimEndNewLine(code);
      const dark = _highlighter.codeToHtml(trimmed, { lang: lang || "text", theme: darkModeThemes.dark }).replace('<pre class="shiki', '<pre class="slidev-code shiki shiki-dark');
      const light = _highlighter.codeToHtml(trimmed, { lang: lang || "text", theme: darkModeThemes.light }).replace('<pre class="shiki', '<pre class="slidev-code shiki shiki-light');
      return escapeVueInCode(`<pre class="shiki-container">${dark}${light}</pre>`);
    } else {
      return escapeVueInCode(
        _highlighter.codeToHtml(code, { lang: lang || "text" }).replace('<pre class="shiki"', '<pre class="slidev-code shiki"')
      );
    }
  };
};
var markdown_it_shiki_default = MarkdownItShiki;

// node/plugins/markdown.ts
var DEFAULT_SHIKI_OPTIONS = {
  theme: {
    dark: "min-dark",
    light: "min-light"
  }
};
async function createMarkdownPlugin({ data: { config }, roots, mode, entry }, { markdown: mdOptions }) {
  const setups = [];
  const entryPath = slash4(entry);
  if (config.highlighter === "shiki") {
    const Shiki = await import("shiki");
    const shikiOptions = await loadSetups(roots, "shiki.ts", Shiki, DEFAULT_SHIKI_OPTIONS, false);
    const { langs, themes } = resolveShikiOptions(shikiOptions);
    shikiOptions.highlighter = await Shiki.getHighlighter({ themes, langs });
    setups.push((md2) => md2.use(markdown_it_shiki_default, shikiOptions));
  } else {
    setups.push((md2) => md2.use(markdownItPrism));
  }
  if (config.mdc)
    setups.push((md2) => md2.use(Mdc));
  const KatexOptions = await loadSetups(roots, "katex.ts", {}, { strict: false }, false);
  return Markdown2({
    include: [/\.md$/],
    wrapperClasses: "",
    headEnabled: false,
    frontmatter: false,
    markdownItOptions: {
      quotes: `""''`,
      html: true,
      xhtmlOut: true,
      linkify: true,
      ...mdOptions?.markdownItOptions
    },
    ...mdOptions,
    markdownItSetup(md2) {
      md2.use(mila2, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
      md2.use(mif);
      md2.use(taskLists, { enabled: true, lineNumber: true, label: true });
      md2.use(math_plugin, KatexOptions);
      setups.forEach((i) => i(md2));
      mdOptions?.markdownItSetup?.(md2);
    },
    transforms: {
      before(code, id) {
        if (id === entryPath)
          return "";
        const monaco = config.monaco === true || config.monaco === mode ? transformMarkdownMonaco : truncateMancoMark;
        code = transformSlotSugar(code);
        code = transformMermaid(code);
        code = transformPlantUml(code, config.plantUmlServer);
        code = monaco(code);
        code = transformHighlighter(code);
        code = transformPageCSS(code, id);
        code = transformKaTex(code);
        return code;
      }
    }
  });
}
function transformKaTex(md2) {
  return md2.replace(/^\$\$(?:\s*{([\d\w*,\|-]+)}\s*?({.*?})?\s*?)?\n([\s\S]+?)^\$\$/mg, (full, rangeStr = "", _, code) => {
    const ranges = rangeStr.split(/\|/g).map((i) => i.trim());
    code = code.trimEnd();
    return `<KaTexBlockWrapper :ranges='${JSON.stringify(ranges)}'>

$$
${code}
$$
</KaTexBlockWrapper>
`;
  });
}
function transformMarkdownMonaco(md2) {
  md2 = md2.replace(/^```(\w+?)\s*{monaco-diff}\s*?({.*?})?\s*?\n([\s\S]+?)^~~~\s*?\n([\s\S]+?)^```/mg, (full, lang = "ts", options = "{}", code, diff) => {
    lang = lang.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    const encodedDiff = base64.encode(diff, true);
    return `<Monaco :code="'${encoded}'" :diff="'${encodedDiff}'" lang="${lang}" v-bind="${options}" />`;
  });
  md2 = md2.replace(/^```(\w+?)\s*{monaco}\s*?({.*?})?\s*?\n([\s\S]+?)^```/mg, (full, lang = "ts", options = "{}", code) => {
    lang = lang.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<Monaco :code="'${encoded}'" lang="${lang}" v-bind="${options}" />`;
  });
  return md2;
}
function truncateMancoMark(md2) {
  return md2.replace(/{monaco.*?}/g, "");
}
function transformSlotSugar(md2) {
  const lines = md2.split(/\r?\n/g);
  let prevSlot = false;
  const { isLineInsideCodeblocks } = getCodeBlocks(md2);
  lines.forEach((line, idx) => {
    if (isLineInsideCodeblocks(idx))
      return;
    const match = line.trimEnd().match(/^::\s*(\w+)\s*::$/);
    if (match) {
      lines[idx] = `${prevSlot ? "\n\n</template>\n" : "\n"}<template v-slot:${match[1]}="slotProps">
`;
      prevSlot = true;
    }
  });
  if (prevSlot)
    lines[lines.length - 1] += "\n\n</template>";
  return lines.join("\n");
}
function transformHighlighter(md2) {
  return md2.replace(/^```(\w+?)(?:\s*{([\d\w*,\|-]+)}\s*?({.*?})?\s*?)?\n([\s\S]+?)^```/mg, (full, lang = "", rangeStr = "", options = "", code) => {
    const ranges = rangeStr.split(/\|/g).map((i) => i.trim());
    code = code.trimEnd();
    options = options.trim() || "{}";
    return `
<CodeBlockWrapper v-bind="${options}" :ranges='${JSON.stringify(ranges)}'>

\`\`\`${lang}
${code}
\`\`\`

</CodeBlockWrapper>`;
  });
}
function getCodeBlocks(md2) {
  const codeblocks = Array.from(md2.matchAll(/^```[\s\S]*?^```/mg)).map((m) => {
    const start = m.index;
    const end = m.index + m[0].length;
    const startLine = md2.slice(0, start).match(/\n/g)?.length || 0;
    const endLine = md2.slice(0, end).match(/\n/g)?.length || 0;
    return [start, end, startLine, endLine];
  });
  return {
    codeblocks,
    isInsideCodeblocks(idx) {
      return codeblocks.some(([s, e]) => s <= idx && idx <= e);
    },
    isLineInsideCodeblocks(line) {
      return codeblocks.some(([, , s, e]) => s <= line && line <= e);
    }
  };
}
function transformPageCSS(md2, id) {
  const page = id.match(/(\d+)\.md$/)?.[1];
  if (!page)
    return md2;
  const { isInsideCodeblocks } = getCodeBlocks(md2);
  const result = md2.replace(
    /(\n<style[^>]*?>)([\s\S]+?)(<\/style>)/g,
    (full, start, css, end, index) => {
      if (index < 0 || isInsideCodeblocks(index))
        return full;
      if (!start.includes("scoped"))
        start = start.replace("<style", "<style scoped");
      return `${start}
${css}${end}`;
    }
  );
  return result;
}
function transformMermaid(md2) {
  return md2.replace(/^```mermaid\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", code = "") => {
    code = code.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<Mermaid :code="'${encoded}'" v-bind="${options}" />`;
  });
}
function transformPlantUml(md2, server) {
  return md2.replace(/^```plantuml\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", content = "") => {
    const code = encode2(content.trim());
    options = options.trim() || "{}";
    return `<PlantUml :code="'${code}'" :server="'${server}'" v-bind="${options}" />`;
  });
}
function escapeVueInCode(md2) {
  return md2.replace(/{{(.*?)}}/g, "&lbrace;&lbrace;$1&rbrace;&rbrace;");
}

// node/plugins/patchTransform.ts
import { objectEntries } from "@antfu/utils";
function createFixPlugins(options) {
  const define = objectEntries(getDefine(options));
  return [
    {
      name: "slidev:flags",
      enforce: "pre",
      transform(code, id) {
        if (id.match(/\.vue($|\?)/)) {
          const original = code;
          define.forEach(([from, to]) => {
            code = code.replace(new RegExp(from, "g"), to);
          });
          if (original !== code)
            return code;
        }
      }
    }
  ];
}

// node/plugins/preset.ts
var customElements = /* @__PURE__ */ new Set([
  // katex
  "annotation",
  "math",
  "menclose",
  "mfrac",
  "mglyph",
  "mi",
  "mlabeledtr",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mroot",
  "mrow",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
]);
async function ViteSlidevPlugin(options, pluginOptions, serverOptions = {}) {
  const {
    vue: vueOptions = {},
    vuejsx: vuejsxOptions = {},
    components: componentsOptions = {},
    icons: iconsOptions = {},
    remoteAssets: remoteAssetsOptions = {},
    serverRef: serverRefOptions = {}
  } = pluginOptions;
  const {
    mode,
    themeRoots,
    addonRoots,
    clientRoot,
    data: { config }
  } = options;
  const VuePlugin = Vue({
    include: [/\.vue$/, /\.md$/],
    exclude: [],
    template: {
      compilerOptions: {
        isCustomElement(tag) {
          return customElements.has(tag);
        }
      },
      ...vueOptions?.template
    },
    ...vueOptions
  });
  const VueJsxPlugin = VueJsx(vuejsxOptions);
  const MarkdownPlugin = await createMarkdownPlugin(options, pluginOptions);
  const drawingData = await loadDrawings(options);
  const publicRoots = themeRoots.map((i) => join8(i, "public")).filter(existsSync3);
  const plugins = [
    MarkdownPlugin,
    VueJsxPlugin,
    VuePlugin,
    createSlidesLoader(options, pluginOptions, serverOptions),
    Components({
      extensions: ["vue", "md", "js", "ts", "jsx", "tsx"],
      dirs: [
        join8(clientRoot, "builtin"),
        join8(clientRoot, "components"),
        ...themeRoots.map((i) => join8(i, "components")),
        ...addonRoots.map((i) => join8(i, "components")),
        "src/components",
        "components"
      ],
      include: [/\.vue$/, /\.vue\?vue/, /\.vue\?v=/, /\.md$/],
      exclude: [],
      resolvers: [
        IconsResolver({
          prefix: "",
          customCollections: Object.keys(iconsOptions.customCollections || [])
        })
      ],
      dts: false,
      ...componentsOptions
    }),
    Icons({
      defaultClass: "slidev-icon",
      autoInstall: true,
      ...iconsOptions
    }),
    config.remoteAssets === true || config.remoteAssets === mode ? import("vite-plugin-remote-assets").then((r) => r.VitePluginRemoteAssets({
      rules: [
        ...r.DefaultRules,
        {
          match: /\b(https?:\/\/image.unsplash\.com.*?)(?=[`'")\]])/ig,
          ext: ".png"
        }
      ],
      resolveMode: (id) => id.endsWith("index.html") ? "relative" : "@fs",
      awaitDownload: mode === "build",
      ...remoteAssetsOptions
    })) : null,
    ServerRef({
      debug: process3.env.NODE_ENV === "development",
      state: {
        sync: false,
        nav: {
          page: 0,
          clicks: 0
        },
        drawings: drawingData,
        ...serverRefOptions.state
      },
      onChanged(key, data, patch, timestamp) {
        serverRefOptions.onChanged && serverRefOptions.onChanged(key, data, patch, timestamp);
        if (!options.data.config.drawings.persist)
          return;
        if (key === "drawings")
          writeDrawings(options, patch ?? data);
      }
    }),
    createConfigPlugin(options),
    createClientSetupPlugin(options),
    createMonacoTypesLoader(),
    createFixPlugins(options),
    publicRoots.length ? import("vite-plugin-static-copy").then((r) => r.viteStaticCopy({
      silent: true,
      targets: publicRoots.map((r2) => ({
        src: `${r2}/*`,
        dest: "theme"
      }))
    })) : null,
    options.inspect ? import("vite-plugin-inspect").then((r) => (r.default || r)({
      dev: true,
      build: true
    })) : null,
    config.css === "none" ? null : config.css === "windicss" ? import("./windicss-MS4GFOSZ.mjs").then((r) => r.createWindiCSSPlugin(options, pluginOptions)) : import("./unocss-BTVZWCXM.mjs").then((r) => r.createUnocssPlugin(options, pluginOptions))
  ];
  return (await Promise.all(plugins)).flat().filter(notNullish2);
}

export {
  getIndexHtml,
  mergeViteConfigs,
  require_fast_deep_equal,
  ViteSlidevPlugin
};
