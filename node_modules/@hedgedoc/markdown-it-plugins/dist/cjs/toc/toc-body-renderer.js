"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderAstToHtml = void 0;
const html_entities_1 = require("html-entities");
function renderAstToHtml(tree, tocOptions) {
    if (tree.children.length === 0) {
        return '';
    }
    let buffer = '';
    const tag = (0, html_entities_1.encode)(tocOptions.listType);
    if (tree.level === 0 || isLevelSelected(tree.level, tocOptions.level)) {
        const listClass = tocOptions.listClass !== '' ? ` class="${(0, html_entities_1.encode)(tocOptions.listClass)}"` : '';
        buffer += `<${tag + listClass}>`;
    }
    const usedSlugs = [];
    const parts = tree.children.map((node) => {
        var _a, _b;
        const subNodesHtml = renderAstToHtml(node, tocOptions);
        if (isLevelSelected(node.level, tocOptions.level)) {
            const anchorContent = (0, html_entities_1.encode)((_b = (_a = tocOptions.format) === null || _a === void 0 ? void 0 : _a.call(tocOptions, node.name)) !== null && _b !== void 0 ? _b : node.name);
            const anchorId = generateUniqueSlug(node.name, tocOptions, usedSlugs);
            usedSlugs.push(anchorId);
            const itemClass = tocOptions.itemClass !== '' ? ` class="${(0, html_entities_1.encode)(tocOptions.itemClass)}"` : '';
            const linkClass = tocOptions.linkClass !== '' ? ` class="${(0, html_entities_1.encode)(tocOptions.linkClass)}"` : '';
            return `<li${itemClass}><a${linkClass} href="#${anchorId}">${anchorContent}</a>${subNodesHtml}</li>`;
        }
        else {
            return subNodesHtml;
        }
    });
    buffer += parts.join('');
    if (tree.level === 0 || isLevelSelected(tree.level, tocOptions.level)) {
        buffer += `</${tag}>`;
    }
    return buffer;
}
exports.renderAstToHtml = renderAstToHtml;
function isLevelSelected(level, levels) {
    return Array.isArray(levels) ? levels.includes(level) : level >= levels;
}
function generateUniqueSlug(slug, tocOptions, usedSlugs) {
    for (let index = tocOptions.uniqueSlugStartIndex; index < Number.MAX_VALUE; index += 1) {
        const slugCandidate = tocOptions.slugify(slug, index);
        const slugWithIndex = index === 0 ? slugCandidate : `${slugCandidate}-${index}`;
        if (!usedSlugs.includes(slugWithIndex)) {
            return slugWithIndex;
        }
    }
    throw new Error('Too many slug with same name');
}
//# sourceMappingURL=toc-body-renderer.js.map