import fs from 'node:fs';
import fsp from 'node:fs/promises';
import { bundledLanguages, bundledThemes, getHighlighter as getHighlighter$1, toShikiTheme } from 'shikiji';
export { toShikiTheme } from 'shikiji';

const _warned = /* @__PURE__ */ new Set();
function warnOnce(message) {
  if (!_warned.has(message)) {
    console.warn(`[shikiji-compat]: ${message}`);
    _warned.add(message);
  }
}
function stubFunction(name) {
  return () => {
    warnOnce(`\`${name}\` is a stub function in \`shikiji-compat\` and does nothing.`);
  };
}
const setCDN = stubFunction("setCDN");
const setOnigasmWASM = stubFunction("setOnigasmWASM");
const setWasm = stubFunction("setWasm");
const setColorReplacements = stubFunction("setColorReplacements");

const BUNDLED_LANGUAGES = bundledLanguages;
const BUNDLED_THEMES = bundledThemes;
async function getHighlighter(options = {}) {
  const themes = options.themes || [];
  const langs = options.langs || [];
  if (options.theme)
    themes.unshift(options.theme);
  if (!themes.length)
    themes.push("nord");
  if (!langs.length)
    langs.push(...Object.keys(bundledLanguages));
  const shikiji = await getHighlighter$1({
    ...options,
    themes,
    langs
  });
  const defaultTheme = shikiji.getLoadedThemes()[0];
  function codeToThemedTokens(code, lang, theme) {
    if (typeof lang === "string") {
      return shikiji.codeToThemedTokens(code, {
        lang,
        theme: theme || defaultTheme
      });
    }
    return shikiji.codeToThemedTokens(code, lang);
  }
  function codeToHtml(code, arg1, arg2, options2) {
    const options3 = (typeof arg1 === "string" ? options2 : arg1) || {};
    if (typeof arg1 === "string")
      options3.lang || (options3.lang = arg1);
    if (!("themes" in options3)) {
      options3.theme = "theme" in options3 ? options3.theme || defaultTheme : arg2 || defaultTheme;
    }
    if (options3.lineOptions) {
      options3.transforms = options3.transforms || {};
      const prev = options3.transforms.line;
      options3.transforms.line = (ast, line) => {
        const node = prev?.(ast, line) || ast;
        const lineOption = options3.lineOptions?.find((o) => o.line === line);
        if (lineOption?.classes) {
          node.properties ?? (node.properties = {});
          node.properties.class = [node.properties.class, ...lineOption.classes].filter(Boolean).join(" ");
        }
        return node;
      };
    }
    return shikiji.codeToHtml(code, options3);
  }
  return {
    ...shikiji,
    codeToThemedTokens,
    codeToHtml,
    ansiToHtml(code, options2) {
      return shikiji.codeToHtml(code, {
        lang: "ansi",
        ...options2,
        theme: options2?.theme || defaultTheme
      });
    }
  };
}
async function loadTheme(theme) {
  if (typeof theme === "string") {
    if (bundledThemes[theme] != null)
      return toShikiTheme(await bundledThemes[theme]().then((r) => r.default));
    if (fs.existsSync(theme) && theme.endsWith(".json"))
      return toShikiTheme(JSON.parse(await fsp.readFile(theme, "utf-8")));
    throw new Error(`[shikiji-compat] Unknown theme: ${theme}`);
  } else {
    return toShikiTheme(await normalizeGetter(theme));
  }
}
async function normalizeGetter(p) {
  return Promise.resolve(typeof p === "function" ? p() : p).then((r) => r.default || r);
}

export { BUNDLED_LANGUAGES, BUNDLED_THEMES, getHighlighter as default, getHighlighter, loadTheme, setCDN, setColorReplacements, setOnigasmWASM, setWasm };
