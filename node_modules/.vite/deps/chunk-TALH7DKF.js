import {
  a
} from "./chunk-BUPAFUC6.js";
import {
  Bt,
  R,
  dr,
  fr,
  gr,
  hr,
  m as m2,
  or,
  pr,
  tr,
  ur,
  xr,
  yr
} from "./chunk-JPMR5MLC.js";
import {
  Zr
} from "./chunk-R2L7EZIU.js";
import {
  Yt,
  m
} from "./chunk-WVAAFYYB.js";
import {
  Ze,
  v
} from "./chunk-JWVTARMW.js";
import {
  Da,
  Jn,
  L,
  Tt
} from "./chunk-CC5SJ7OS.js";

// node_modules/mermaid/dist/index-7a48438c.js
function m3(e) {
  var t = {
    options: {
      directed: e.isDirected(),
      multigraph: e.isMultigraph(),
      compound: e.isCompound()
    },
    nodes: tt(e),
    edges: et(e)
  };
  return v(e.graph()) || (t.value = a(e.graph())), t;
}
function tt(e) {
  return m(e.nodes(), function(t) {
    var n = e.node(t), r = e.parent(t), i = { v: t };
    return v(n) || (i.value = n), v(r) || (i.parent = r), i;
  });
}
function et(e) {
  return m(e.edges(), function(t) {
    var n = e.edge(t), r = { v: t.v, w: t.w };
    return v(t.name) || (r.name = t.name), v(n) || (r.value = n), r;
  });
}
var l = {};
var g = {};
var P = {};
var nt = () => {
  g = {}, P = {}, l = {};
};
var B = (e, t) => (L.trace("In isDescendant", t, " ", e, " = ", g[t].includes(e)), !!g[t].includes(e));
var it = (e, t) => (L.info("Descendants of ", t, " is ", g[t]), L.info("Edge is ", e), e.v === t || e.w === t ? false : g[t] ? g[t].includes(e.v) || B(e.v, t) || B(e.w, t) || g[t].includes(e.w) : (L.debug("Tilt, ", t, ",not in descendants"), false));
var k = (e, t, n, r) => {
  L.warn(
    "Copying children of ",
    e,
    "root",
    r,
    "data",
    t.node(e),
    r
  );
  const i = t.children(e) || [];
  e !== r && i.push(e), L.warn("Copying (nodes) clusterId", e, "nodes", i), i.forEach((a2) => {
    if (t.children(a2).length > 0)
      k(a2, t, n, r);
    else {
      const d = t.node(a2);
      L.info("cp ", a2, " to ", r, " with parent ", e), n.setNode(a2, d), r !== t.parent(a2) && (L.warn("Setting parent", a2, t.parent(a2)), n.setParent(a2, t.parent(a2))), e !== r && a2 !== e ? (L.debug("Setting parent", a2, e), n.setParent(a2, e)) : (L.info("In copy ", e, "root", r, "data", t.node(e), r), L.debug(
        "Not Setting parent for node=",
        a2,
        "cluster!==rootId",
        e !== r,
        "node!==clusterId",
        a2 !== e
      ));
      const u = t.edges(a2);
      L.debug("Copying Edges", u), u.forEach((f) => {
        L.info("Edge", f);
        const h = t.edge(f.v, f.w, f.name);
        L.info("Edge data", h, r);
        try {
          it(f, r) ? (L.info("Copying as ", f.v, f.w, h, f.name), n.setEdge(f.v, f.w, h, f.name), L.info("newGraph edges ", n.edges(), n.edge(n.edges()[0]))) : L.info(
            "Skipping copy of edge ",
            f.v,
            "-->",
            f.w,
            " rootId: ",
            r,
            " clusterId:",
            e
          );
        } catch (w) {
          L.error(w);
        }
      });
    }
    L.debug("Removing node", a2), t.removeNode(a2);
  });
};
var $ = (e, t) => {
  const n = t.children(e);
  let r = [...n];
  for (const i of n)
    P[i] = e, r = [...r, ...$(i, t)];
  return r;
};
var C = (e, t) => {
  L.trace("Searching", e);
  const n = t.children(e);
  if (L.trace("Searching children of id ", e, n), n.length < 1)
    return L.trace("This is a valid node", e), e;
  for (const r of n) {
    const i = C(r, t);
    if (i)
      return L.trace("Found replacement for", e, " => ", i), i;
  }
};
var X = (e) => !l[e] || !l[e].externalConnections ? e : l[e] ? l[e].id : e;
var st = (e, t) => {
  if (!e || t > 10) {
    L.debug("Opting out, no graph ");
    return;
  } else
    L.debug("Opting in, graph ");
  e.nodes().forEach(function(n) {
    e.children(n).length > 0 && (L.warn(
      "Cluster identified",
      n,
      " Replacement id in edges: ",
      C(n, e)
    ), g[n] = $(n, e), l[n] = { id: C(n, e), clusterData: e.node(n) });
  }), e.nodes().forEach(function(n) {
    const r = e.children(n), i = e.edges();
    r.length > 0 ? (L.debug("Cluster identified", n, g), i.forEach((a2) => {
      if (a2.v !== n && a2.w !== n) {
        const d = B(a2.v, n), u = B(a2.w, n);
        d ^ u && (L.warn("Edge: ", a2, " leaves cluster ", n), L.warn("Descendants of XXX ", n, ": ", g[n]), l[n].externalConnections = true);
      }
    })) : L.debug("Not a cluster ", n, g);
  });
  for (let n of Object.keys(l)) {
    const r = l[n].id, i = e.parent(r);
    i !== n && l[i] && !l[i].externalConnections && (l[n].id = i);
  }
  e.edges().forEach(function(n) {
    const r = e.edge(n);
    L.warn("Edge " + n.v + " -> " + n.w + ": " + JSON.stringify(n)), L.warn("Edge " + n.v + " -> " + n.w + ": " + JSON.stringify(e.edge(n)));
    let i = n.v, a2 = n.w;
    if (L.warn(
      "Fix XXX",
      l,
      "ids:",
      n.v,
      n.w,
      "Translating: ",
      l[n.v],
      " --- ",
      l[n.w]
    ), l[n.v] && l[n.w] && l[n.v] === l[n.w]) {
      L.warn("Fixing and trixing link to self - removing XXX", n.v, n.w, n.name), L.warn("Fixing and trixing - removing XXX", n.v, n.w, n.name), i = X(n.v), a2 = X(n.w), e.removeEdge(n.v, n.w, n.name);
      const d = n.w + "---" + n.v;
      e.setNode(d, {
        domId: d,
        id: d,
        labelStyle: "",
        labelText: r.label,
        padding: 0,
        shape: "labelRect",
        style: ""
      });
      const u = structuredClone(r), f = structuredClone(r);
      u.label = "", u.arrowTypeEnd = "none", f.label = "", u.fromCluster = n.v, f.toCluster = n.v, e.setEdge(i, d, u, n.name + "-cyclic-special"), e.setEdge(d, a2, f, n.name + "-cyclic-special");
    } else if (l[n.v] || l[n.w]) {
      if (L.warn("Fixing and trixing - removing XXX", n.v, n.w, n.name), i = X(n.v), a2 = X(n.w), e.removeEdge(n.v, n.w, n.name), i !== n.v) {
        const d = e.parent(i);
        l[d].externalConnections = true, r.fromCluster = n.v;
      }
      if (a2 !== n.w) {
        const d = e.parent(a2);
        l[d].externalConnections = true, r.toCluster = n.w;
      }
      L.warn("Fix Replacing with XXX", i, a2, n.name), e.setEdge(i, a2, r, n.name);
    }
  }), L.warn("Adjusted Graph", m3(e)), F(e, 0), L.trace(l);
};
var F = (e, t) => {
  if (L.warn("extractor - ", t, m3(e), e.children("D")), t > 10) {
    L.error("Bailing out");
    return;
  }
  let n = e.nodes(), r = false;
  for (const i of n) {
    const a2 = e.children(i);
    r = r || a2.length > 0;
  }
  if (!r) {
    L.debug("Done, no node has children", e.nodes());
    return;
  }
  L.debug("Nodes = ", n, t);
  for (const i of n)
    if (L.debug(
      "Extracting node",
      i,
      l,
      l[i] && !l[i].externalConnections,
      !e.parent(i),
      e.node(i),
      e.children("D"),
      " Depth ",
      t
    ), !l[i])
      L.debug("Not a cluster", i, t);
    else if (!l[i].externalConnections && // !graph.parent(node) &&
    e.children(i) && e.children(i).length > 0) {
      L.warn(
        "Cluster without external connections, without a parent and with children",
        i,
        t
      );
      let d = e.graph().rankdir === "TB" ? "LR" : "TB";
      l[i] && l[i].clusterData && l[i].clusterData.dir && (d = l[i].clusterData.dir, L.warn("Fixing dir", l[i].clusterData.dir, d));
      const u = new Ze({
        multigraph: true,
        compound: true
      }).setGraph({
        rankdir: d,
        // Todo: set proper spacing
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function() {
        return {};
      });
      L.warn("Old graph before copy", m3(e)), k(i, e, u, i), e.setNode(i, {
        clusterNode: true,
        id: i,
        clusterData: l[i].clusterData,
        labelText: l[i].labelText,
        graph: u
      }), L.warn("New graph after copy node: (", i, ")", m3(u)), L.debug("Old graph after copy", m3(e));
    } else
      L.warn(
        "Cluster ** ",
        i,
        " **not meeting the criteria !externalConnections:",
        !l[i].externalConnections,
        " no parent: ",
        !e.parent(i),
        " children ",
        e.children(i) && e.children(i).length > 0,
        e.children("D"),
        t
      ), L.debug(l);
  n = e.nodes(), L.warn("New list of nodes", n);
  for (const i of n) {
    const a2 = e.node(i);
    L.warn(" Now next level", i, a2), a2.clusterNode && F(a2.graph, t + 1);
  }
};
var G = (e, t) => {
  if (t.length === 0)
    return [];
  let n = Object.assign(t);
  return t.forEach((r) => {
    const i = e.children(r), a2 = G(e, i);
    n = [...n, ...a2];
  }), n;
};
var rt = (e) => G(e, e.children());
var at = (e, t) => {
  L.info("Creating subgraph rect for ", t.id, t);
  const n = Jn(), r = e.insert("g").attr("class", "cluster" + (t.class ? " " + t.class : "")).attr("id", t.id), i = r.insert("rect", ":first-child"), a2 = Da(n.flowchart.htmlLabels), d = r.insert("g").attr("class", "cluster-label"), u = t.labelType === "markdown" ? Zr(d, t.labelText, { style: t.labelStyle, useHtmlLabels: a2 }) : d.node().appendChild(R(t.labelText, t.labelStyle, void 0, true));
  let f = u.getBBox();
  if (Da(n.flowchart.htmlLabels)) {
    const c = u.children[0], o = Tt(u);
    f = c.getBoundingClientRect(), o.attr("width", f.width), o.attr("height", f.height);
  }
  const h = 0 * t.padding, w = h / 2, x = t.width <= f.width + h ? f.width + h : t.width;
  t.width <= f.width + h ? t.diff = (f.width - t.width) / 2 - t.padding / 2 : t.diff = -t.padding / 2, L.trace("Data ", t, JSON.stringify(t)), i.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", t.x - x / 2).attr("y", t.y - t.height / 2 - w).attr("width", x).attr("height", t.height + h);
  const { subGraphTitleTopMargin: v2 } = tr(n);
  a2 ? d.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${t.x - f.width / 2}, ${t.y - t.height / 2 + v2})`
  ) : d.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${t.x}, ${t.y - t.height / 2 + v2})`
  );
  const y = i.node().getBBox();
  return t.width = y.width, t.height = y.height, t.intersect = function(c) {
    return Bt(t, c);
  }, r;
};
var ct = (e, t) => {
  const n = e.insert("g").attr("class", "note-cluster").attr("id", t.id), r = n.insert("rect", ":first-child"), i = 0 * t.padding, a2 = i / 2;
  r.attr("rx", t.rx).attr("ry", t.ry).attr("x", t.x - t.width / 2 - a2).attr("y", t.y - t.height / 2 - a2).attr("width", t.width + i).attr("height", t.height + i).attr("fill", "none");
  const d = r.node().getBBox();
  return t.width = d.width, t.height = d.height, t.intersect = function(u) {
    return Bt(t, u);
  }, n;
};
var ot = (e, t) => {
  const n = Jn(), r = e.insert("g").attr("class", t.classes).attr("id", t.id), i = r.insert("rect", ":first-child"), a2 = r.insert("g").attr("class", "cluster-label"), d = r.append("rect"), u = a2.node().appendChild(R(t.labelText, t.labelStyle, void 0, true));
  let f = u.getBBox();
  if (Da(n.flowchart.htmlLabels)) {
    const c = u.children[0], o = Tt(u);
    f = c.getBoundingClientRect(), o.attr("width", f.width), o.attr("height", f.height);
  }
  f = u.getBBox();
  const h = 0 * t.padding, w = h / 2, x = t.width <= f.width + t.padding ? f.width + t.padding : t.width;
  t.width <= f.width + t.padding ? t.diff = (f.width + t.padding * 0 - t.width) / 2 : t.diff = -t.padding / 2, i.attr("class", "outer").attr("x", t.x - x / 2 - w).attr("y", t.y - t.height / 2 - w).attr("width", x + h).attr("height", t.height + h), d.attr("class", "inner").attr("x", t.x - x / 2 - w).attr("y", t.y - t.height / 2 - w + f.height - 1).attr("width", x + h).attr("height", t.height + h - f.height - 3);
  const { subGraphTitleTopMargin: v2 } = tr(n);
  a2.attr(
    "transform",
    `translate(${t.x - f.width / 2}, ${t.y - t.height / 2 - t.padding / 3 + (Da(n.flowchart.htmlLabels) ? 5 : 3) + v2})`
  );
  const y = i.node().getBBox();
  return t.height = y.height, t.intersect = function(c) {
    return Bt(t, c);
  }, r;
};
var lt = (e, t) => {
  const n = e.insert("g").attr("class", t.classes).attr("id", t.id), r = n.insert("rect", ":first-child"), i = 0 * t.padding, a2 = i / 2;
  r.attr("class", "divider").attr("x", t.x - t.width / 2 - a2).attr("y", t.y - t.height / 2).attr("width", t.width + i).attr("height", t.height + i);
  const d = r.node().getBBox();
  return t.width = d.width, t.height = d.height, t.diff = -t.padding / 2, t.intersect = function(u) {
    return Bt(t, u);
  }, n;
};
var ft = { rect: at, roundedWithTitle: ot, noteGroup: ct, divider: lt };
var j = {};
var dt = (e, t) => {
  L.trace("Inserting cluster");
  const n = t.shape || "rect";
  j[t.id] = ft[n](e, t);
};
var ut = () => {
  j = {};
};
var M = async (e, t, n, r, i, a2) => {
  L.info("Graph in recursive render: XXX", m3(t), i);
  const d = t.graph().rankdir;
  L.trace("Dir in recursive render - dir:", d);
  const u = e.insert("g").attr("class", "root");
  t.nodes() ? L.info("Recursive render XXX", t.nodes()) : L.info("No nodes found for", t), t.edges().length > 0 && L.trace("Recursive edges", t.edge(t.edges()[0]));
  const f = u.insert("g").attr("class", "clusters"), h = u.insert("g").attr("class", "edgePaths"), w = u.insert("g").attr("class", "edgeLabels"), x = u.insert("g").attr("class", "nodes");
  await Promise.all(
    t.nodes().map(async function(c) {
      const o = t.node(c);
      if (i !== void 0) {
        const b = JSON.parse(JSON.stringify(i.clusterData));
        L.info("Setting data for cluster XXX (", c, ") ", b, i), t.setNode(i.id, b), t.parent(c) || (L.trace("Setting parent", c, i.id), t.setParent(c, i.id, b));
      }
      if (L.info("(Insert) Node XXX" + c + ": " + JSON.stringify(t.node(c))), o && o.clusterNode) {
        L.info("Cluster identified", c, o.width, t.node(c));
        const b = await M(
          x,
          o.graph,
          n,
          r,
          t.node(c),
          a2
        ), E = b.elem;
        m2(o, E), o.diff = b.diff || 0, L.info("Node bounds (abc123)", c, o, o.width, o.x, o.y), yr(E, o), L.warn("Recursive render complete ", E, o);
      } else
        t.children(c).length > 0 ? (L.info("Cluster - the non recursive path XXX", c, o.id, o, t), L.info(C(o.id, t)), l[o.id] = { id: C(o.id, t), node: o }) : (L.info("Node - the non recursive path", c, o.id, o), await or(x, t.node(c), d));
    })
  ), t.edges().forEach(function(c) {
    const o = t.edge(c.v, c.w, c.name);
    L.info("Edge " + c.v + " -> " + c.w + ": " + JSON.stringify(c)), L.info("Edge " + c.v + " -> " + c.w + ": ", c, " ", JSON.stringify(t.edge(c))), L.info("Fix", l, "ids:", c.v, c.w, "Translating: ", l[c.v], l[c.w]), xr(w, o);
  }), t.edges().forEach(function(c) {
    L.info("Edge " + c.v + " -> " + c.w + ": " + JSON.stringify(c));
  }), L.info("#############################################"), L.info("###                Layout                 ###"), L.info("#############################################"), L.info(t), Yt(t), L.info("Graph after layout:", m3(t));
  let v2 = 0;
  const { subGraphTitleTotalMargin: y } = tr(a2);
  return rt(t).forEach(function(c) {
    const o = t.node(c);
    L.info("Position " + c + ": " + JSON.stringify(t.node(c))), L.info(
      "Position " + c + ": (" + o.x,
      "," + o.y,
      ") width: ",
      o.width,
      " height: ",
      o.height
    ), o && o.clusterNode ? (o.y += y, pr(o)) : t.children(c).length > 0 ? (o.height += y, dt(f, o), l[o.id].node = o) : (o.y += y / 2, pr(o));
  }), t.edges().forEach(function(c) {
    const o = t.edge(c);
    L.info("Edge " + c.v + " -> " + c.w + ": " + JSON.stringify(o), o), o.points.forEach((E) => E.y += y / 2);
    const b = ur(h, c, o, l, n, t, r);
    gr(o, b);
  }), t.nodes().forEach(function(c) {
    const o = t.node(c);
    L.info(c, o.type, o.diff), o.type === "group" && (v2 = o.diff);
  }), { elem: u, diff: v2 };
};
var bt = async (e, t, n, r, i) => {
  hr(e, n, r, i), fr(), dr(), ut(), nt(), L.warn("Graph at first:", JSON.stringify(m3(t))), st(t), L.warn("Graph after:", JSON.stringify(m3(t)));
  const a2 = Jn();
  await M(e, t, r, i, void 0, a2);
};

export {
  bt
};
//# sourceMappingURL=chunk-TALH7DKF.js.map
